package OSM2Tramod;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

//import org.locationtech.jts.io.ParseException;

public class Modifier {

	//private Records records;
	private DataContainer dataContainer;
	
	public Modifier(DataContainer dataContainer) {
		this.setDataContainer(dataContainer);
		//this.setModifiedLines(new ModifiedLines());
		
		System.out.println("Modifier succesfully initialized.");
		
	}

	public void execute(){
		int duplex = 0, nonDuplex = 0;
		
		
		for (LineOSM line : this.getDataContainer().getLines().getLineList()) {
			if(line.isDuplex()) {
				//this.getModifiedLines().getLines().add(new LineChangesTree(line));
				this.dataContainer.getModifiedLines().getLines().put(line.getID() ,new LineChangesTree(line));
				duplex++;
			}
			else {
				nonDuplex++;
			}	
		}
		this.processLines();
		this.processVertexes();
		this.convertVertexesCoordinates();
	}

	private void convertVertexesCoordinates() {
		try {
			this.dataContainer.getVertexes().convertToCoordinates();
		} catch (Exception e) {
			System.out.println("Something went wrong in Coordinates conversion");
			e.printStackTrace();
		}
		
	}

	private void processLines() {
		int newIDcounter = this.getDataContainer().getLines().getLineList().size();
		
		for (Map.Entry<Integer, LineChangesTree> line : this.dataContainer.getModifiedLines().getLines().entrySet()) {
            line.getValue().modify(++newIDcounter);
            //line.getValue().printChanges();
        }
		
		System.out.println("Lines successfully modified. Modified " + this.dataContainer.getModifiedLines().getLines().size() + " lines.");
		
	}
	
	private void processVertexes() {
		String restrictionFullString;
		String originalRestriction;
		String newRestriction;
		String regexRestriction = "[-]\\d*_\\d*";
		Pattern patternRestriction = Pattern.compile(regexRestriction);
		String regexOrder = "[+]\\d*_\\d*";
		Pattern patternOrder = Pattern.compile(regexOrder);
		
		for (Vertex vertex : this.dataContainer.getVertexes().getVertexList()) {
			if(vertex.hasTurnRestriction()) {
				
				restrictionFullString = vertex.getRestrictions().replaceAll("'", "");
				originalRestriction = vertex.getRestrictions().replaceAll("'", "");
				
				//THIS PART CREATES RESTRICTIONS OUT OF ORDERS
				Matcher matcherOrder = patternOrder.matcher(restrictionFullString);
				
				List<String> orders = new ArrayList<>();
				while(matcherOrder.find()) {
					orders.add(matcherOrder.group());
				}
				
				for (String order : orders) {
					newRestriction = orderToRestriction(vertex, order, originalRestriction);
					restrictionFullString = restrictionFullString.replace(order, newRestriction);
				}
				
				
				//THIS PART SWITCHES ALL RESTRICTIONS IF NEEDED
				Matcher matcherRestriction = patternRestriction.matcher(restrictionFullString);
				
				List<String> restrictions = new ArrayList<>();
				while (matcherRestriction.find()) {
				    restrictions.add(matcherRestriction.group());
				}
				
				String resTmp;
				String[] resSplit;
				for (String restriction : restrictions) {
					restriction = turnRestrictionSwitch(vertex, restriction);
					resTmp = restriction.replaceAll("-", "");
					resSplit = resTmp.split("_");
					
					if(!resSplit[0].equals("0") && !resSplit[1].equals("0")) {
						TurnRestriction tmpTR = new TurnRestriction(String.valueOf(vertex.getID()), resSplit[0], resSplit[1], "-1");
						if(!dataContainer.getTurnRestrictions().isAlreadyRestricted(String.valueOf(vertex.getID()), resSplit[0], resSplit[1])) { // nepřidávání duplicit
							dataContainer.getTurnRestrictions().getTurnRestrictionList().add(tmpTR);
						}
						
					}
				}
				
				
				
				String newRestrictionString = "'";
				
				for (String restriction : restrictions) {
					newRestrictionString += restriction;
				}
				
				newRestrictionString += "'";
				
				vertex.setRestrictions(newRestrictionString);
				
			}	
		}
	}

	private String orderToRestriction(Vertex vertex, String order, String restrictionFullString) {
		String orderSplit[];
		String newRestrictions = "";
		String potentialRestriction;
		String orderToCheck;
		
		//System.out.println("______________" + "\nrestrictionFullString: " +restrictionFullString + "\norder: " + order );
		
		order = order.replaceAll("\\+", "");
		orderSplit = order.split("_");
		
		
		for (LineOSM line : this.dataContainer.getLines().getLineList()) {
			if((vertex.getID()==Integer.valueOf(line.getSource()))||(vertex.getID()==Integer.valueOf(line.getTarget()))) {
				orderToCheck = "+" + orderSplit[0] + "_" + Integer.toString(line.getID());
				potentialRestriction = "-" + orderSplit[0] + "_" + Integer.toString(line.getID());
				if(!restrictionFullString.contains(orderToCheck)) {
					newRestrictions += potentialRestriction;
				}
			}
		}
		//System.out.println(newRestrictions);
		//System.out.println(restrictionFullString);
		return newRestrictions;
	}

	//Otočí turn_restrictions z důvodu předem neznámému orientovanému grafu
	private String turnRestrictionSwitch(Vertex vertex, String restriction) {
		
		String restrictionSplit[];
		String oldLine, newLine;
		LineChangesTree line;
		
		restriction = restriction.replaceAll("-", "");
		restrictionSplit = restriction.split("_");
		
		//odkud -> kam ----> hledam, jestli existuje lajna v modified, ktera ma tenhle vertex jako targe
		if (this.dataContainer.getModifiedLines().getLines().containsKey(Integer.valueOf(restrictionSplit[0]))) {
			line = this.dataContainer.getModifiedLines().getLines().get(Integer.valueOf(restrictionSplit[0]));
			if(vertex.getID() == Integer.valueOf(line.getNewLine().getTarget())) {
				restrictionSplit[0] = Integer.toString(line.getNewLine().getID());
			}
			else {
				//restrictionSplit[0] = Integer.toString(line.getCopiedLine().getID());
				restrictionSplit[0] = Integer.toString(line.getOriginalLine().getID());
			}
			
		}
		//odkud -> kam ----> hledam, jestli existuje lajna v modified, ktera ma tenhle vertex jako source
		if (this.dataContainer.getModifiedLines().getLines().containsKey(Integer.valueOf(restrictionSplit[1]))) {
			line = this.dataContainer.getModifiedLines().getLines().get(Integer.valueOf(restrictionSplit[1]));
			if(vertex.getID() == Integer.valueOf(line.getNewLine().getSource())) {
				restrictionSplit[1] = Integer.toString(line.getNewLine().getID());
			}
			else {
				//restrictionSplit[1] = Integer.toString(line.getCopiedLine().getID());
				restrictionSplit[1] = Integer.toString(line.getOriginalLine().getID());
			}
			
		}
		restriction = "-" + restrictionSplit[0] + "_" + restrictionSplit[1];
		return restriction;
	}

	/*public Records getRecords() {
		return records;
	}

	public void setRecords(Records records) {
		this.records = records;
	}
*/
	public DataContainer getDataContainer() {
		return dataContainer;
	}

	public void setDataContainer(DataContainer dataContainer) {
		this.dataContainer = dataContainer;
	}

	public void calculateBuildingAreas() {
		for (OSMBuilding osmBuilding : dataContainer.getBuildings()) {
			osmBuilding.calculateArea();
		}
		
	}

	public void calculateBuildingCentroids() {
		
		for (OSMBuilding osmBuilding : dataContainer.getBuildings()) {
			osmBuilding.calculateCentroid();
		}
		
	}

	public void processGrid(int userGridRequest) {
		dataContainer.getGrid().init(userGridRequest, dataContainer.getBounds());
		System.out.println("Grid initialized...");
		
		System.out.println("Assigning buildings to grid...");
		dataContainer.getGrid().calculateGenerators(dataContainer.getBuildings());
		
		System.out.println("Generators calculated for grid...");

		
	}

	public void assignTrafficGenerators() {
		dataContainer.getGrid().assignGenerators(dataContainer.getVertexes().getVertexList());
		
	}

	public void assignVertexlessGenerators() {

		GridLocator maxGL, tmpGL;
		int[] dX = { -1,0,1 };
		int[] dY = { -1,0,1 };
		double maxTG = 0.0, tmpTG;
		
		int counter = 0;
		Iterator<HashMap.Entry<GridLocator, Tile>> it = dataContainer.getGrid().getTiles().entrySet().iterator();
		
		while (it.hasNext()) {
			HashMap.Entry<GridLocator, Tile> pair = it.next();
			maxTG = 0.0;
			maxGL = null;
			
			
			if(pair.getValue().getVertex() == null) {		
			
				for (int i = 0; i < dY.length; i++) {
				
					for (int j = 0; j < dX.length; j++) {
					
						tmpGL = new GridLocator(pair.getKey().getX()+dX[j], pair.getKey().getY()+dY[i]);
						
						if(dataContainer.getGrid().getTiles().containsKey(tmpGL)) {
							if(dataContainer.getGrid().getTiles().get(tmpGL).getVertex()!=null) {
								if(dataContainer.getGrid().getTiles().get(tmpGL).getTrafficGenerator() > maxTG) {
									maxGL = tmpGL;
									maxTG = dataContainer.getGrid().getTiles().get(tmpGL).getTrafficGenerator();
								}
							}
						}
					}
				}
				if(maxGL != null) {
					tmpTG = pair.getValue().getTrafficGenerator() + maxTG;
					pair.getValue().setTrafficGenerator(tmpTG);	
				}
				else {
					System.out.println("Tile with centroid: " + pair.getValue().getCentroid().getLon() + " " + pair.getValue().getCentroid().getLat() + " wasn`t assigned to any crossroad!");
					System.out.println("Grid is too dense!");
				}
				
			}
		}
		
	}


}
